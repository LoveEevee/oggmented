<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
</head>

<body>
    HTML page I created for my WebAssembly moduule.
    <!-- <script type="module" src=decode.js></script> -->
    <!-- <script src=decode.js></script> -->
    <script src="main.js"></script>
    <!-- <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        newAudioCtx = Module()
        fetch('gm.ogg')
            .then(response => response.arrayBuffer())
            .then(response => {
                const audioBuffer = newAudioCtx.audioBufferFromOggBuffer(response)
                const source = audioCtx.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioCtx.destination);
                source.start()
            })

        // console.log(Module)
        // fetch('gm.ogg')
        //     .then(response => response.arrayBuffer())
        //     .then(response => {
        //         const audioBuffer = Module().audioBufferFromOggBuffer(response)
        //         const source = audioCtx.createBufferSource();
        //         source.buffer = audioBuffer;
        //         source.connect(audioCtx.destination);
        //         source.start()
        //     })
        // var audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });//{sampleRate: 48000}
        // console.log(audioCtx)
        // var Module = {
        //     onRuntimeInitialized: function () {
        //         openBuffer = (inbuffer) => {
        //             const size = inbuffer.byteLength
        //             const buffer = Module._malloc(size)
        //             const bufferView = new Int8Array(inbuffer)
        //             Module.HEAP8.set(bufferView, buffer)
        //             Module.ccall('open_buffer', 'number', ['number', 'number'], [buffer, size])
        //             return {
        //                 length: Module._get_length(),
        //                 channels: Module._get_channels(),
        //                 rate: Module._get_rate()
        //             }
        //         }
        //         decode = (buffer) => {
        //             const info = openBuffer(buffer)
        //             const length = info.length
        //             const channels = info.channels
        //             const rate = info.rate
        //             const audioBuffer = audioCtx.createBuffer(channels, length, rate);
        //             const ppp_pcm = Module._malloc(Uint32Array.BYTES_PER_ELEMENT)
        //             let index = 0;
        //             block = () => {
        //                 const time = Date.now()
        //                 let samplesRead = 0;
        //                 while (samplesRead = Module._read_float(ppp_pcm)) {
        //                     const pp_pcm = Module.getValue(ppp_pcm, '*')
        //                     const pp_pcm_view = new Uint32Array(Module.HEAP32.buffer, pp_pcm, channels)
        //                     for (let channel = 0; channel < channels; channel++) {
        //                         const p_pcm = pp_pcm_view[channel]
        //                         const p_pcm_view = new Float32Array(Module.HEAPF32.buffer, p_pcm, samplesRead)
        //                         audioBuffer.copyToChannel(p_pcm_view, channel, index);
        //                     }
        //                     index += samplesRead
        //                     if (time + 10 < Date.now()) {
        //                         window.setImmediate(block)
        //                         break
        //                     }
        //                 }
        //                 if (samplesRead === 0) {
        //                     console.timeEnd("take2")
        //                     for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        //                         console.log(audioBuffer.getChannelData(i)) //[12000000]
        //                     }
        //                 }
        //             }
        //             block()
        //             var source = audioCtx.createBufferSource();
        //             console.log(audioBuffer)
        //             source.buffer = audioBuffer;

        //             source.connect(audioCtx.destination);
        //             source.start();
        //         }
        //         console.log(Module)
        //         fetch('gm.ogg')
        //             .then(response => response.arrayBuffer())
        //             .then(response => { console.time("Native"); return audioCtx.decodeAudioData(response) })
        //             .then(response => {
        //                 console.timeEnd("Native")
        //                 var source = audioCtx.createBufferSource();
        //                 source.buffer = response;

        //                 source.connect(audioCtx.destination);
        //                 // source.start();
        //                 console.log(response)
        //                 for (let i = 0; i < response.numberOfChannels; i++) {
        //                     console.log(response.getChannelData(i)) //[12000000]
        //                 }
        //             })
        //             .then(() =>
        //                 fetch('gm.ogg')
        //                     .then(response => response.arrayBuffer())
        //                     .then(response => {
        //                         console.log(response)
        //                         console.time("take2")

        //                         decode(response)
        //                         // console.timeEnd("take2")
        //                     }))
        //     }

        // };
    </script> -->

    <!-- <script src=setImmediate.js></script> -->
</body>

</html>